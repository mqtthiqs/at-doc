{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Creative Audio Workbench</p>"},{"location":"#atelier","title":"Atelier","text":""},{"location":"#patch-play-discover","title":"Patch, play, discover","text":"<p>Atelier is a sandbox for the curious, a platform for exploring endless sonic ideas. Modular at its core, multichannel from the ground up, it is the modern tool for all sound adventurers. Atelier doesn't hand you the sound: it gives you everything you need to uncover it yourself.</p> <p>Standing on decades of research in audio signal processing and electronic lutherie, Atelier is the new software platform of the GRM Tools series, coming straight from INA GRM's research &amp; development department and developed in close connection with GRM's avant-garde composers and sound designers.</p>"},{"location":"#whats-in-the-box","title":"What's in the box","text":"<p>Atelier is a standalone application and a plug-in for DAWs (VST3, AUv2, AAX) for macOS (Windows support coming soon). Atelier comprises a set of modules, which are freely chainable and connectible:</p> <ul> <li>Processors which generate or transform sound, and</li> <li>Modulators which generate modulations, freely assignable to any parameter</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Polyadic Modulation Engine: A novel modulation paradigm: organic and per-voice control, making it fast and expressive to build complex, evolving patches. Everything modulatable, no artifacts.</li> <li>Full Multichannel Support: Create in stereo, quad, or 64+ channels without changing how you work. Perfect for spatial composition.</li> <li>Groundbreaking yet simple modules: From granular delays to multi-playhead samplers, modules are simple and understandable, yet reward curiosity and creative misuse.</li> <li>Hybrid Workflow: Sound generation and processing in one place; build an advanced synth, a granular FX chain, or something never seen before.</li> <li>Parameter Morphing: Transition between module snapshots or randomize parameters with smooth sonic interpolation, ideal for performance, evolving patches or simply to be surprised.</li> </ul>"},{"location":"#modules","title":"Modules","text":""},{"location":"#philosophy","title":"Philosophy","text":"<ul> <li>By enthusiasts, for enthusiasts: Like you, we are all passionate musicians and curious minds. We exchange every day with avant-garde electronic music composers at GRM. Atelier is built by a small and dedicated team inside a public institution. Our favorite question is \"what if?\". We have a unique goal: make the universally-accessible instrument we are dreaming of. No market considerations: all decisions taken by enthusiasts, for enthusiasts.</li> <li>The magic is in the making: true to Pierre Schaeffer's founding principles of composing by directly interacting with the musical material (\"Le faire et l'entendre\"), everything in Atelier is real-time, interactive and modulatable. No forethought necessary, no music knowledge required: be guided by what you hear.</li> <li>Just tools: Every module has simple and easy to understand functions: everything is observable and documented, nothing is a black box; there is no wrong way to use them. Just by playing, you will learn how things work, and discover new uses for the tools. Keep it simple or build something complex; we are just giving you the tools to do so.</li> <li>Functional user interface: The UI never gets in the way: every element on screen has an informative function, and no menu or tabs hides important information. A single screenshot should be enough to get a grasp of a patch.</li> <li>Classics, reinvented: Atelier is a reinvention of the venerable GRM Tools suite: while respecting and preserving the underlying philosophy, it bears no single line of code in common with its older sibling.</li> </ul>"},{"location":"#the-beginning-of-a-beautiful-friendship","title":"The beginning of a beautiful friendship","text":"<p>Atelier is built to grow. As we develop new features it will evolve over time, including new modules, processors and modulators, and new core features. Your purchase of Atelier <code>v1.x</code> is a lifetime purchase: no subscription, no recurring fees. It includes all features that will be introduced in point-updates, (about 1.5\u20142 years worth of upgrades). When <code>v2.0</code> is released, we will propose discounted upgrade paths for existing <code>v1.x</code> user.</p>"},{"location":"atelier/faq/","title":"Frequently Asked Questions","text":""},{"location":"atelier/faq/#sales-policies","title":"Sales policies","text":""},{"location":"atelier/faq/#is-there-a-demo-version-of-atelier","title":"Is there a demo version of Atelier?","text":"<p>Yes, Atelier runs in demo mode until you activate it. In demo mode, saving is not supported, and the sound fades regularly to silence. Download the unique installer to get it; you don't need an account for this.</p>"},{"location":"atelier/faq/#can-i-install-atelier-on-more-than-one-computer","title":"Can I install Atelier on more than one computer?","text":"<p>Yes. Each license purchased comes with 3 activations, assignable freely.</p>"},{"location":"atelier/faq/#do-i-need-an-internet-connection-to-activate-my-copy","title":"Do I need an internet connection to activate my copy?","text":"<p>Yes, our licensing scheme requires an internet connection on activation, but never after activation. Once Atelier has been activated on your machine, you are free to disconnect forever.</p>"},{"location":"atelier/faq/#do-you-offer-education-discount","title":"Do you offer education discount?","text":"<p>Yes, we happily do! Students and teachers benefit from a 35% discount. When creating an account, just check the right option and the rate will be applied automatically.</p>"},{"location":"atelier/faq/#can-i-resell-or-give-my-license-to-another-user","title":"Can I resell or give my license to another user?","text":"<p>We do not support license transfer at this point.</p>"},{"location":"atelier/faq/#what-is-your-return-or-refund-policy","title":"What is your return or refund policy?","text":"<p>[TODO]</p>"},{"location":"atelier/faq/#using-the-software","title":"Using the software","text":""},{"location":"atelier/faq/#what-are-the-system-requirements-for-running-atelier","title":"What are the system requirements for running Atelier?","text":"<p>Atelier runs on Intel and Apple Silicon Macs. The oldest OS supported is macOS 10.14 Mojave (2018). It runs fine on a 2015 Macbook Pro with 8 Gb RAM.</p>"},{"location":"atelier/faq/#do-you-support-42th-order-ambisonics-dolby-atmos-dtsx","title":"Do you support 42th-order ambisonics, Dolby Atmos, DTS:X?","text":"<p>We don't, and it is a choice. Atelier supports multichannel processing in a discrete and format-agnostic way. For Atelier, a channel is a channel: we make no presupposition on where it is placed in space or if it has a special function. This allows more flexibility at the composition stage, and you can rely on plenty of other tools to encode a set of discrete channels coming from Atelier into your specific format.</p>"},{"location":"atelier/faq/#something-seems-wrong-where-are-the-global-settings-stored","title":"Something seems wrong; where are the global settings stored?","text":"<p>First, if you think you encountered a bug, please contact us! You are probably not alone.</p> <p>The application's audio configuration, recent files and last loaded patch are stored in a hidden file in your <code>Application Support</code> directory. In case you need to delete it, back it up or restore it:</p> <ul> <li>Open a Finder window</li> <li>In the \"Go\" menu, select \"Go to folder...\" or type <code>\u21e7-\u2318-G</code></li> <li>In the popup, enter <code>~/Library/Application Support/</code></li> <li>The configuration file is <code>com.INAgrm.GRMTools.Atelier.settings</code></li> </ul>"},{"location":"atelier/faq/#i-saved-some-snapshots-on-a-module-but-they-disappeared-after-starting-a-new-patch","title":"I saved some snapshots on a module, but they disappeared after starting a new patch","text":"<p>Module snapshots are saved in a patch and can be different for each instances of each module. There is no way to save (yet). Do reach out if you think it would be useful to you.</p>"},{"location":"atelier/faq/#morphing-is-cool-but-where-do-i-set-the-morph-time","title":"Morphing is cool, but where do I set the morph time?","text":"<p>The Morph Time slider is in the sidebar on the right. It applies to morphing when loading a snapshot, when randomizing, and sets the speed of elastic moves.</p>"},{"location":"atelier/faq/#ive-found-a-bug-how-do-i-report-it","title":"I've found a bug. How do i report it?","text":"<p>We are eager to hear your feedback! If you encounter a bug contact us at grmtools.support@ina.fr. Please include step-by-step instructions and patches to help us reproduce the bug. The about dialog (found by clicking on the INA GRM logo) includes all necessary information about your system. Please include a screenshot.</p> <p>Thanks again for you help to improve Atelier!</p>"},{"location":"atelier/getting-started/","title":"Getting Started","text":"<p>Thanks for your interest in GRM Tools Atelier! Here are a few steps to get you started making sound with Atelier.</p>"},{"location":"atelier/getting-started/#installation","title":"Installation","text":"<p>Running the installer will install on your system:</p> <ul> <li>The standalone application in <code>/Applications</code>;</li> <li>The GRM Tools Atelier plug-in, in all the supported plug-in formats:<ul> <li>AAX for use with Avid Pro Tools, in <code>/Library/Application Support/Avid/Audio/Plug-ins</code>;</li> <li>AU for use with Apple Logic and compatible hosts, in <code>/Library/Audio/Plugins/Components</code>;</li> <li>VST3 for use in most other hosts, in <code>/Library/Audio/Plugins/VST3</code>;</li> </ul> </li> <li>Example patches to get you started.</li> </ul>"},{"location":"atelier/getting-started/#authorization","title":"Authorization","text":"<p>On the first start (app or standalone), you will be invited to authorize your beta copy. Follow the indicated steps, and paste the code that was sent back to you. Once the authorization popup disappears, you are ready to go.</p>"},{"location":"atelier/getting-started/#application-audio-midi-setup","title":"Application audio &amp; MIDI setup","text":"<p>Then, set up your audio interface. In the status bar, click the gear icon to reveal the settings:</p> <p></p> <ul> <li>select an output device, and enable all channels connected to your speakers</li> <li>optionally select an input device and enable the corresponding channels</li> <li>optionally set up any MIDI controller below</li> <li>watch out for feedback if you have a microphone near your loudspeakers, then untick \"Mute audio input\"</li> </ul> <p>The number of output channels set up determines how many channels the processors will work with.</p>"},{"location":"atelier/getting-started/#use-as-a-plug-in","title":"Use as a plug-in","text":"<p>Atelier can be used as a plug-in in a VST3/AU/AAX host. The plug-in and the standalone app offer the exact same functionality; patches created on one can be used with the other.</p>"},{"location":"atelier/getting-started/#and-now","title":"And now?","text":"<p>When first started, Atelier greets you with an empty patch, showing the list of available processors. Sound is passed through, unaffected.</p> <p></p> <p>Note</p> <p>Subsequently when the application is started, it opens the last opened patch.</p> <p>Insert a processor from the splash screen and start playing around. All controls are documented in the info area in the status bar. Click the \"+\" buttons to add other modules, either processors or modulators. Processors process sound in series, from left to right; drag a module from its title bar to move it. Drag a wire from the colored round handle of a modulator and start modulating a parameter.</p> <p></p> <p>In the status bar next to the file icons is the patch browser. Click it to bring up the factory-supplied library of patches, draw some inspiration and explore the capabilities of GRM Tools Atelier.</p> <p>In the sidebar are two meters and their associated gain sliders: input and output.</p> <p></p> <p>Once satisfied with the result, either save the patch (File &gt; Save) or record an audio file in real time by clicking the \"Record\" button in the bottom right corner. The recording has as many channels as the number of outputs configured and is 32 bits floating point, so you don't have to worry about clipping.</p> <p>The resulting file will be saved on the desktop by default, or in the current patch's directory. Click the \"Burger\" button to view all recordings and modify the destination directory.</p> <p>Note</p> <p>In the recorded file list popup, files can be dragged e.g. to your DAW's window, or directly in the Atelier window (processor row), which makes a new instance of Play. Perfect for on-the-fly resampling!</p> <p>Happy patching!</p>"},{"location":"atelier/midi-and-automation/","title":"MIDI and automations","text":"<p>Atelier provides a simple way to map any parameter to your hardware MIDI controllers or keyboards. Similarly, any parameter can be automated from your DAW when used as a plug-in.</p>"},{"location":"atelier/midi-and-automation/#midi-mapping","title":"MIDI mapping","text":"<p>To use a MIDI device, enable it in the Audio and MIDI setup. If your device has motorized faders, LEDs or any visual feedback, select it in MIDI Output: then, any parameter change in the software should be reflected on the hardware.</p> <p>Once your setup is ready:</p> <ol> <li>Right-click on the slider or button you want to control,</li> <li> <p>from the menu choose Learn MIDI. The Parameter mappings window pops-up with the selected parameter highlighted:</p> <p></p> </li> <li> <p>Move a fader, turn a knob or press a key. The MIDI event appears in the MIDI column of the mappings table. Click anywhere to accept, or click on the trash bin icon to abort.</p> </li> <li> <p>A dashed blue outline is drawn around the control to indicate that it is mapped.</p> </li> </ol> <p>Atelier understands three kinds of MIDI messages:</p> <ol> <li>Control Changes (CC): their values (0-127) map to parameter values linearly.</li> <li>Pitch wheel: same thing.</li> <li>Individual MIDI notes: Each MIDI note is a separately assignable control. Note-on messages map to the value of their velocity; note-off messages map to the minimum value.</li> </ol> <p>Notes</p> <ul> <li>If you want one controller to control several parameters just create a Control module and set it up to control several parameters.</li> <li>If you use Atelier as a plug-in and need MIDI mappings, you might need to set up your DAW to forward MIDI messages to the track.</li> <li>Classic VST instrument playing (\"hit a key to make a note\") is not supported. Yet.</li> </ul>"},{"location":"atelier/midi-and-automation/#automations","title":"Automations","text":"<p>Just like any other plug-in, any parameter in Atelier can be automated through your DAW. But because of its modular nature and the limitations of plug-in formats, automation first has to be manually enabled for each parameter you want to automate. This is two clicks away:</p> <ol> <li>right-click on the button or slider you want to automate, and</li> <li>click on Automate Parameter.</li> </ol> <p>The control's outline is then highlighted with a dashed blue line.</p> <p>Note</p> <p>Internally, Atelier will automatically map the parameter to one of 64 available automation slot.  Should you need to, you can see which automation slot it is mapped to by either right-clicking on the control or in the mappings window.</p>"},{"location":"atelier/midi-and-automation/#the-parameter-mappings-window","title":"The parameter mappings window","text":"<p>The parameter mappings window is where MIDI and automations mappings are listed and can be edited. The automation column is only displayed in the plug-in.</p> <p>Drag a cable from the bottom blue dot to quickly make a new row. Hovering over each row's filled blue dots shows a cable to the mapped control. Drag a new wire from it to re-map a row to a different parameter.</p>"},{"location":"atelier/modulation/","title":"The modulation system","text":"<p>A new modulation paradigm</p> <p>In Atelier just like on modern modular synthesizers, all parameters (sliders, cursors, buttons etc.) can be modulated. But Atelier's polyadic modulation system goes far further than its analog parent, offering a new paradigm to interact with your modules. It is the key to constructing living, evolving patches, provoke surprises and\u00a0program complex interactions.</p> <p>Animate a whole family of parameters in one click, let complex random movements guide your explorations (Agitation), construct tailor-made macro-controls for live interaction (Control), or trigger advanced envelopes with customizable contours (Peak)... If the modules of Atelier are its sound-processing heart, the modulation system is certainly its brain.</p>"},{"location":"atelier/modulation/#features","title":"Features","text":"<ul> <li>Polyadic: each destination is its own independent modulation engine</li> <li>Accumulatable: scale and sum as many modulations to a single parameter as wanted</li> <li>Composable: all modulators parameters are themselves modulatable, polyadically</li> </ul>"},{"location":"atelier/modulation/#getting-started","title":"Getting started","text":"<p>Modulation is a classic technique from analog synthesis (also known as CV): instead of moving a parameter manually, a modulator generates a signal that moves it automatically. You may for instance modulate the gain of some audio input with a sine LFO (low frequency oscillator) to get a tremolo effect.</p> <p></p> <p>Click the \"+\" button in the bottom row of the interface to instantiate a modulator (e.g. Agitation). Each modulator has a handle in the top right corner (colored round); drag a wire from the handle to the parameter of your choice to make a new connection.</p> <p>Once a connection is made, the parameter is modulated relatively to its nominal value (the current position of the slider, the state of the button etc.). Its actual value is displayed as a small grey dot on sliders and buttons. Hovering over a modulated parameter shows a popup where one can scale the modulation, or remove a connection.</p> <p>Hovering over a modulator's handle displays its outgoing wires. Hold \"w\" or press the \"Show all connected wires\" button in the status bar to see all wires.</p> <p></p> <p>Note</p> <p>You can give each modulator instance a name: click on the empty space between the \"close\" button and the colored handle. This helps remembering who does what.</p>"},{"location":"atelier/modulation/#polyadic-modulation","title":"Polyadic modulation","text":"<p>In Atelier, all modulations are polyadic: if a modulator is connected to several destination parameters, each destination gets its own independent modulation engine. Each of these modulations, while sharing the modulator's parameters (speed, amplitude etc.), can have its own internal phase, random state etc.</p> <p>Try connecting the same modulator, say, an Agitation, to two different parameters: the two parameters will be agitated differently. Changing, say, the agitation's frequency will act on the two parameters, but the random trajectories of each modulations will stay independent.</p> <p></p> <p>This is in stark contrast with classic modulation in analog synthesis: if one was to patch a single source of modulation (e.g. an LFO) into several destinations (by multing its output), each destination would receive the exact same LFO signal. This new paradigm opens up a wealth of workflow improvements and discovery avenues that would be difficult to imagine traditionally.</p>"},{"location":"atelier/modulation/#parameter-instances","title":"Parameter instances","text":"<p>Moreover, when a single parameter actually controls several things at once, each of these things is modulated independently: parameters can have several instances. For instance, the Ratio slider in Gen applies a ratio to all oscillators' frequencies; if there are three oscillators enabled, Ratio has three instances: agitating Ratio will agitate the three actual ratios independently.</p> <p></p> <p>The number of instances of a modulated parameter is shown on its wire (e.g. \"x3\"), and its actual values are displayed as grey dots on the button/slider.</p>"},{"location":"atelier/modulation/#accumulating-modulations","title":"Accumulating modulations","text":"<p>A parameter can receive several connections from several modulator (and even from the same modulator). Just drag several wires to the same parameter; modulations are summed together, and the parameter's popup displays the list of connections. Each connection has its own range (-200% to 200%).</p> <p></p> <p>Note</p> <p>The 100% range of all modulators is able to span the entire range of a parameter, either bipolarly (plus or minus half the range), or unipolarly (0 to full range). If at some point the sum of the nominal parameter value and all its modulations exceed the limit of the parameter, it is clamped to the limit.</p> <p>Note</p> <p>On/off buttons (like Play's play/pause buttons) can also be modulated, but they differ from continuous parameters: if the sum of their modulation is positive, their actual value is the same  as their nominal value (the state of the button); if it is negative, it is inverted.</p>"},{"location":"atelier/modulation/#modulating-the-modulators","title":"Modulating the modulators","text":"<p>All modulators parameters are themselves modulatable: just drag a wire from one modulator to another modulator's parameter. These connections themselves are also polyadic: A modulator parameter has as many instances as there are connections going out of it. In other words, if a modulator's parameter is in turn modulated, each of its destination will spawn an individually-modulated modulator!</p> <p></p> <p>For instance, if three oscillator in Gen have their pitch modulated by the same agitation, and another agitation modulates its frequency, then each of the three pitch modulations will see its frequency agitated independently.</p> <p>Note</p> <p>Because of their polyadic nature, modulation feedback loops do not make sense (they would require infinitely many parameter instances). The signal path of modulations must therefore be loop-free; Atelier will warn you whenever your patch involves a feedback loop.</p>"},{"location":"atelier/modulation/#tips-tricks","title":"Tips &amp; tricks","text":""},{"location":"atelier/modulation/#brownian-agitation","title":"Brownian agitation","text":"<p>Make 3 Agitations, and set them up with increasing frequencies (say, 0.1 Hz, 1 Hz and 10 Hz) and decreasing amplitudes (say, 60%, 30% and 5%). Now modulate a parameter with these three; the three agitations are summed together and result in a multi-scale agitation: large, smooth movements are combined with smaller, faster one. Increasing the number of agitations involved, we get closer and closer to what is known in physics as brownian motion (see also Perlin noise).</p>"},{"location":"atelier/modulation/#multiple-connections","title":"Multiple connections","text":"<p>What happens if we connect a modulator, say an Agitation, to the same parameter multiple times, say 5 times? Each connection spawns an independent random oscillator, and they are all summed together. Let's reduce the amplitude to 20% (1/5th of 100%) so it does not risk clamping the parameter. The sum of all agitations is a random signal that has more chance to be found around 0 (close to the nominal parameter value), much like rolling 5 dices and summing the figures will get you a number likely close to 15 (5 * 6 / 2).</p> <p>Got it? Now try to predict what will happen with a Peak set to 50% chance of triggering.</p>"},{"location":"atelier/multichannel/","title":"Multichannel processing","text":"<p>Spatial thinking is often put aside during composition, and left as a mixing afterthought. Where most creative audio tools only work in mono or stereo, Atelier brings multichannel processing to the composition stage. Want to process mono sound? Fine. Want to render your generative patch on a 32-channel loudspeaker dome? Works too. There are no limits other than your CPU.</p> <p>Essentially, Atelier scales to how many channels you want use, and does not make any assumption where they are placed. All processors apply the same processing on all channels. The result can then be downmixed or spatialized into the required format using any available tool. Therefore, a patch produced in one setup will automatically scale to fit any other setup, following a few simple rules.</p>"},{"location":"atelier/multichannel/#setup","title":"Setup","text":"<p>The number of outputs set up determines how many channels processors work with.</p> <ul> <li>In the app, set it in the Audio and MIDI configuration.</li> <li>The plug-in adapts to the configuration of the track it is on.</li> </ul> <p>If the number of inputs and outputs differ, fanning and folding is applied to distribute the channels as evenly as possible. This way, a mono input from a microphone will be distributed to both stereo output channels.</p>"},{"location":"atelier/multichannel/#channel-colors","title":"Channel colors","text":"<p>Throughout Atelier, channels are identified by specific colors: Channel 1 is green, 2 is red etc.</p> <p></p> <p>They are chosen so that they always add to white. Therefore, a saturated color identifies a specific channel, and the closer to white it gets, the more it represents a blend of several channel. White means \"all channels\".</p>"},{"location":"atelier/multichannel/#spread","title":"Spread","text":"<p>In processors, the Spread parameter is your key to distributing processing units to channels. Spread controls channel locality: \"focused on some channels\" vs. \"spread out to all\".</p> <p></p> <p>Single processing units (a generator, a comb filter etc.) are represented by cursors (colored discs with a halo). Each cursor automatically gets assigned one or more channels by fanning and folding. When a cursor is selected, these are visible in the panel below, next to its name.</p> <p>The Spread parameter determines what channel each unit (here, comb filter) processes:</p> <ul> <li>When Spread is 0%, processing is local to only its assigned channels. Here, Comb 1 will only process Channels 1 and 5.</li> <li>When Spread is 100%, all channels are processed the same way. Here, each of the 4 comb filters processes each channel, and the result is mixed per channel.</li> </ul> <p>Note</p> <p>This assignment is not editable. It is what makes this system adaptive to any I/O configuration.</p>"},{"location":"atelier/multichannel/#fanning-and-folding","title":"Fanning and folding","text":"<p>Channels are assigned to units so that all channels are processed and all units are used. It follows a few simple rules:</p> <ul> <li>If there are more channels than units, each unit is assigned several channels (fanning). In particular, a single unit will always be assigned all channels.</li> <li>If there are as many or more units than channels, each unit is assigned one channel, with some units possibly sharing channels; therefore their output is mixed (folding). In particular, if there are as many channels than units, each unit is simply assigned a unique channel.</li> <li>For a given unit, channels are assigned such that they are the most \"spread out\", i.e. minimize \"clusters\" of adjacent channels (1,2,3). For instance, two comb filters acting on four channels will give the assignment (1,3) for Comb 1 and (2,4) for Comb 2.</li> </ul> <p>This principle applies as well to distribute inputs to outputs, and to match file and processor channel counts in Play.</p>"},{"location":"atelier/snapshots-and-randomizer/","title":"Snapshots and randomizer","text":"<p>Easily store and recall the state of a whole processor in one click with snapshots. Leave creative decisions to chance and get inspired by surprise with the randomizer. All of this instantaneously, or continuously transitioning over time with morphing. Shifting shapes, unpredictable destinations... Atelier is about the journey as much as the result.</p>"},{"location":"atelier/snapshots-and-randomizer/#snapshots","title":"Snapshots","text":"<p>Each processor features a bank of eight snapshots at the bottom of its interface:</p> <p></p> <p>To capture a snapshot, <code>\u2318</code>-click on one of the eight snapshot buttons; it lights up, indicating that it contains a custom snapshot. Snapshots are saved with your patches. Each instance of a module has independent custom snapshots.</p> <p>Note</p> <p>Snapshots include all sliders, buttons and cursors position, and certain other data like the file loaded in Play, or the widget sizes in Viz.</p> <p>To recall a snapshot click on its button. The processor's parameters start morphing from their current state to the state stored in the snapshot. A white outline around a button indicates the currently-selected snapshot; when any parameter is manually moved, the outline becomes grey, as a reminder of the last selected snapshot.</p> <p>The currently-selected snapshot (from 1 to 8) is itself a parameter, and therefore modulatable and mappable: just draw a cable to the snapshots area. A little dot in the corner indicates its actual value; it blinks while in transition. This way you can control or randomize the invocation of pre-saved scenes.</p>"},{"location":"atelier/snapshots-and-randomizer/#randomizer","title":"Randomizer","text":"<p>Randomization is a way to find new ideas, or just sprinkle a bit of surprise on top of your patch. When randomized, a parameter start morphing from its current value to a new random value. You can randomize:</p> <ul> <li>A single parameter by right-clicking or pressing <code>R</code> while hovering it,</li> <li>A group of parameters by selecting several cursors, and pressing <code>R</code> while hovering over one of their sliders in the panel below,</li> <li>A whole processor by clicking Randomize (dice icon) next to the snapshot buttons</li> <li>A whole patch by clicking Randomize (dice icon) in the sidebar</li> </ul> <p>Contrarily to snapshots, randomization won't add or remove cursors; add the desired cursors before randomizing.</p> <p>Tip</p> <p>The processor-level Randomize button is itself modulatable and mappable. The patch-level Randomize button is only mappable.</p> <p>The Random amount slider in the sidebar controls how subtle or dramatic the randomization will be. The lower the amount, the closer the new random value will remain from the current one. 100% makes the new value completely random.</p> <p>Warning</p> <p>Because randomization affects parameters like gain and feedback, patches may suddenly produce very loud sounds. Work with low headphone levels when using this feature!</p>"},{"location":"atelier/snapshots-and-randomizer/#locking","title":"Locking","text":"<p>You can exclude certain parameters from randomization or snapshot recall using locking. Right-click on a control or on a module's title bar and select Lock. Locked parameters are:</p> <ul> <li>not randomized,</li> <li>not recalled when recalling a snapshot,</li> <li>not saved when saving a snapshot.</li> </ul> <p>By locking some parameters and saving a snapshot, you therefore save a \"partial\" snapshot that will leave some parameters as-is when recalled (even if they are unlocked afterwards).</p>"},{"location":"atelier/snapshots-and-randomizer/#morphing","title":"Morphing","text":"<p>Both snapshot recall and randomization smoothly morph from the current state to the new one, by interpolating each parameter separately. The Morph time slider in the sidebar sets this transition time.</p> <p>If you modify any affected parameters during morphing, it stops morphing. The morphing duration is determined by the value of Morph time at the moment you initiate it. You could for example set Morph time to one minute, trigger a recall, then set Morph time to a much shorter value to randomize a few other parameters.</p>"},{"location":"atelier/snapshots-and-randomizer/#elastic-drag","title":"Elastic drag","text":"<p>To ease smooth movements, sliders and cursors also support elastic drag. Hold down <code>\u2318</code> while dragging the control to smoothly move it to the desired position. You can control the elasticity of the drag operation using the Morph time slider.</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#processors","title":"Processors","text":""},{"location":"modules/#modulators","title":"Modulators","text":""},{"location":"modules/agitation/","title":"Agitation","text":"<p>Source of possibility</p>"},{"location":"modules/agitation/#agitation","title":"Agitation","text":"<p>Agitation is a versatile source of random modulations, able to turn any static sound-processing patch into a dynamic and evolving system of interactions. From subtle variation to utter chaos, from predictible to surprising, it will give life to the most inert material. It is the essential wellspring of all things generative... and more!</p>"},{"location":"modules/agitation/#context","title":"Context","text":"<p>The use of randomness as a composition tool is as old as programmatic music, and it is understating it to say that it plays an essential role in the development of electronic music, from John Cage's aleatoric compositions to dedicated early modular synthesizer functions (e.g. \"sample and hold\").</p> <p>At its core, an Agitation is an oscillator which chooses a new random target value at each of its steps, and smoothly ramps to it. With the ability to continuously ease this ramp into a steep stairstep (Ease), or control the predictability of its phase (Cyclic, Slant), it offers a wide range of controllable random waveforms. And since modulations are polyadic, each destination an agitation connects to will get a different random signal (Multiplicity).</p> <p>Note</p> <p>Agitation signals are bipolar, meaning they move equally above and below the destination parameter's set value. Therefore, to modulate across its full range of without clamping, the destination parameter must be centered and range set to 100%.</p>"},{"location":"modules/agitation/#controls","title":"Controls","text":"<p>Every parameter has as many independently-modulatable instances as there are outgoing instances of this modulator (ie. the sum of all wires' instance number, see Modulation).</p> <ul> <li>Amplitude: Amplitude of the agitation signals.</li> <li>Frequency: Determines the time between two successive random steps. Goes down to 0 Hz (stalled).</li> <li>Ease: Shape of the transition between two successive random steps. At 0%, the shape is sine-like; at 100% it jumps immediately to the next value; at -100% it stays at the current value until the last moment.</li> <li>Slant: Ratio of the time spent going up vs. going down. At 0%, it spends the same time raising than falling.</li> <li>Cyclic: Periodicity of the successive random steps, from completely random to fully cyclic (alternating up and down).</li> <li>Jitter: Amount of randomization of the time between two successive steps.</li> <li>Running: Enable to run; when disabled, will finish its current transition and then stall.</li> <li>Multiplicity: When enabled, each destination has its own independent agitation engine; when disabled, they all move in unison.</li> </ul> <p>Note</p> <p>The relative phases of agitations are chosen at random on initialization; they are not saved with the patch.</p>"},{"location":"modules/agitation/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/agitation/#agitate-it","title":"Agitate it","text":"<p>Many parameters in Atelier will benefit from a slow (5-30 seconds-long) and very small (0.1% to 1% amplitude) agitation. A bank of tuned oscillators in Gen will spring to analog life when their frequency Ratio is very slightly agitated. An aggregate of comb filters around 50 Hz will turn from metallic resonance to soft reverberation when Transposition slowly moves. The Feedback of Time, set up with a few taps, will easily be tamed with tiny movements in the delay times (Delay scale).</p>"},{"location":"modules/agitation/#statues","title":"Statues","text":"<p>Agitate a bunch of parameters in your patch at a relatively high frequency (5 Hz). With another, slower agitation in \"unison mode\" (Multiplicity off), modulate the Running button of the first. Parameters will regularly stall at random values, before continuing their run. A slightly different effect can be achieved by modulating Frequency with a rectangular wave reaching 0 Hz.</p>"},{"location":"modules/band/","title":"Band","text":"<p>Spectral chisel</p>"},{"location":"modules/band/#band","title":"Band","text":"<p>From subtle timbre corrections to drastic shape alterations, Band carves into frequencies like in clay. Feed it audio and start isolating spectral regions, put forth or gently reduce tonal elements, or totally change the frequency profile of your material. Unlike a traditional EQ, more creative than technical, Band is a spectral sculptor's tool of choice.</p>"},{"location":"modules/band/#features","title":"Features","text":"<ul> <li>Precise filter bank with up to 16 independent &amp; spatializable bands</li> <li>Continuous slope setting for razor-sharp selectivity or gentle pushes</li> <li>Adjustable formant-shaping bumps at transition frequencies</li> <li>Band-pass or band-reject modes per band</li> </ul>"},{"location":"modules/band/#context","title":"Context","text":"<p>Filtering can be a transformative tool, letting you freely shape the spectral content of your sounds. Band is a bank of independently-controlled filters, cutting, reducing or amplifying parts of its input's spectrum. Each band lets you either remove the low and high frequencies, keeping only a precise band of interest (band-pass), or notch out a band, keeping everything surrounding it intact (band-reject). Each band has an independent gain; band shapes are then combined additively, resulting in any desired frequency response. And like all other modules, bands are assigned to one or several channels, for multichannel filtering.</p> <p>Note</p> <p>Under the hood, Band uses linear-phase FFT processing; this is what makes its versatility and precision, but also implies:</p> <ul> <li>a natural latency of around 2000 samples, i.e. 20 ms at 96kHz, 40 ms at 48kHz, etc. As usual, the higher the sample rate, the smaller the latency.</li> <li>some pre-ringing when the slope is extremely steep. If that's a problem, increasing Slope to a few semitones drastically reduces ringing.</li> </ul>"},{"location":"modules/band/#controls","title":"Controls","text":""},{"location":"modules/band/#cursor-area","title":"Cursor Area","text":"<p>Click to add a band; double-click a band to remove it. Each band is visualized by a color gradient of its assigned channels colors (see Spread). Each channel's frequency response is visualized by a thick, solid line.</p> <ul> <li>Y axis parameter: The combo box determines which parameter is displayed on the Y axis (and consequently which is displayed on the Z axis, ie. cursors' halo size): either Gain or Width.</li> </ul> <p>Each band has three parameters:</p> <ul> <li>Pitch (X axis): Center frequency of the band</li> <li>Width (Y or Z axis): Width of the band, in semitones. Positive width means band-pass, negative width means band-reject.</li> <li> <p>Gain (Z or Y axis): Gain of the band</p> </li> <li> <p>Transposition: Transposes all bands center frequencies. This parameter has as many independently-modulatable instances as there are bands (see Modulation).</p> </li> </ul>"},{"location":"modules/band/#global-controls","title":"Global controls","text":"<ul> <li>Mix: Crossfades between the dry (0%) and the wet signal (100%).</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are bands (see Modulation).</p> <ul> <li>Spread: Channel-locality of each band. At 0%, each band processes only the channels it is assigned to (see the global Spread section); at 100%, all bands process all channels in parallel (multi-mono).</li> <li>Gain: Global gain of all bands.</li> <li>Slope: Number of semitones to transition from cutting to passing, and conversely.</li> <li>Bump: Adds a bell-shaped boost at the transition frequencies. The bump's width is determined by Slope, and its height is in ratio of the gain.</li> </ul>"},{"location":"modules/band/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/band/#low-pass-high-pass","title":"Low pass, high pass","text":"<p>When the Pitch of a band is at its minimum value, Width can do low and high-pass. Positive Width values result in a low-pass filter with increasingly low cutoff; negative Width values result in a high-pass filter with increasingly high cutoff.</p>"},{"location":"modules/band/#animated-formants","title":"Animated formants","text":"<p>Feed Band with a ~50Hz sawtooth wave e.g. from Gen. Add a few bands in the middle, with Width around 15st, Slope around 6st, and Bump around 1x. Make an agitation, and agitate Transposition: The two bands agitate independently, producing evolving guttural drones. A cheap thrill.</p>"},{"location":"modules/band/#band-splits","title":"Band splits","text":"<p>Band can split a signal into disjoint bands, for further independent processing. Add as many bands as there are channels, and adjust Slope to taste. Place them so that they sum to zero: For this, temporarily set Spread to 100%, make the frequency response (solid white line) as flat as possible, then set Spread back to 0%. You can follow Band with e.g. a Pitch instance, to pitch-shift and/or delay each band by a different amount.</p> <p>Factory snapshots 2 or 3 illustrate this technique.</p>"},{"location":"modules/band/#graphic-equalizer","title":"Graphic equalizer","text":"<p>Make a few bands covering the whole spectrum and summing to zero (see previous tip), with Spread at 0%. A slightly increased Slope will smoothen the bands and reduce ringing. Now display Gain on the Y axis (Y axis parameter), and adjust the gain of each band as desired. Use the Option key to lock the X axis when dragging a band. You now have a graphic equalizer.</p> <p>Factory snapshots 4 and 5 illustrate this technique.</p>"},{"location":"modules/comb/","title":"Comb","text":"<p>Resonance treasure trove</p>"},{"location":"modules/comb/#comb","title":"Comb","text":"<p>The comb filter is arguably the most basic building block of signal processing. Let's turn it into a creative tool! With a handful of carefully-chosen additions, Comb makes a simple component into it a fun and versatile physical modeling-inspired instrument with wide sonic possibilities: subtle coloring, massive reverberations, nuances of wooden or metallic tones... Whether used as an end-of-chain effect or as an integral synthesis block, Comb is a resonance treasure trove.</p>"},{"location":"modules/comb/#features","title":"Features","text":"<ul> <li>Bread-and-butter, reinvented: from simple delay line to complex evolving tones</li> <li>Multiple, precisely tunable comb filters with independent controls</li> <li>Advanced physical modeling-inspired parameters for a wide sonic palette</li> </ul>"},{"location":"modules/comb/#context","title":"Context","text":"<p>A comb filter is simply a very short delay with feedback. It mimics what happens in nature when sound bounces back and forth between two surfaces; it is what makes the particular sound of a physical enclosure (instrument, room...).</p> <p>As the delay gets shorter, we stop perceiving the repeats as echoes, and start hearing them as pitches: the shorter the delay, the higher the pitch. If, just as in nature, we shave off some of the high frequencies at each repetition, the tone gets more mellow over time, simulating the propagation of a wave along a string. Fed with bursts of noise, this is often called Karplus-Strong synthesis. Comb takes this classic to new digital waveguide territories with precise control over damping, unique inharmonic warping of partials and pick-up positioning for interesting phasing effects.</p>"},{"location":"modules/comb/#controls","title":"Controls","text":""},{"location":"modules/comb/#cursor-area","title":"Cursor area","text":"<p>Click to add a comb filter; double-click a comb filter to remove it. Each comb filter processes each input channel; they run in parallel and are mixed to the output.</p> <p>Each comb filter has three controls:</p> <ul> <li>Pitch (X axis): Resonance frequency.</li> <li>Decay (Y axis): Decay time to -60dB. If the decay time is set to more than 20 sec, the decay is infinite: fed with a short impulse it will ring forever.</li> <li>Gain (Z axis): Output gain of the comb filter.</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are comb filters (see Modulation).</p> <ul> <li>Transposition: Transposes all comb filters by a given amount of semitones.</li> <li>Decay scale: Scales all decay times.</li> </ul> <p>Finally the Quantize button quantizes all filter frequencies to the closest semitone.</p>"},{"location":"modules/comb/#global-controls","title":"Global controls","text":"<ul> <li>Mix: Crossfades the dry signal (0%) with the wet signal (100%).</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are comb filters (see Modulation).</p> <ul> <li>Spread: Channel-locality of each comb filter's processes. At 0%, each comb filter processes only the channels it is assigned to (see the global Spread section); at 100%, each comb filter processes all channels in parallel (multi-mono).</li> <li>Gain: Output gain of all comb filters.</li> <li>Damp: Amount of damping, or how much high frequencies are attenuated as decay progresses. At 0%, no damping is applied, leading to metallic tones; at 100%, the filter rapidly converges to the resonance frequency.</li> <li>Warp: Warps the resonance partials, from purely harmonic (0%) to weirdly dissonant. It works by introducing a complex all-pass filter in the feedback loop, delaying some frequencies more than others at each round-trip.</li> <li>Phase: Controls where in the delay loop the output signal is picked up, i.e. only at the end (0%) or in the middle as the sum of the forward and backward direction (100%). At 100%, phase cancellations are such that only odd harmonics ring.</li> <li>Predelay: Introduces a short delay before the input signal hits the comb filter loop.</li> </ul>"},{"location":"modules/comb/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/comb/#noise-bursts","title":"Noise bursts","text":"<p>Comb shines with transient-rich input material. Using Gen and Peak, make short bursts of noise. Follow with a single comb filter at a relatively high Decay (&gt;1s); put Mix at 100%, and adjust Damp and the noise's length and color to taste to get a wide variety of plucked strings, glassy tone, bell sounds etc.</p>"},{"location":"modules/comb/#strummed-chords","title":"Strummed chords","text":"<p>Building on the previous tip, add more comb filters at different frequencies to make a chord. Now, put Predelay around 50ms, and modulate it slightly with a slow Agitation. Every filter will get its own randomly-evolving predelay, resulting in a \"strumming\" effect, as if strings were not plucked all at the same time.</p>"},{"location":"modules/comb/#infinite-decay","title":"Infinite decay","text":"<p>When Decay is set to more than 20 sec and Warp is 0%, decay is infinite: any short-lived input will resonate (almost) forever. Fed with an initial short signal, this can be useful to generate held tones, drones or textures.</p> <p>Note</p> <p>Infinite decay works only if either Damp or Warp is 0% (one of the two).</p>"},{"location":"modules/comb/#crude-reverb","title":"Crude reverb","text":"<p>Early digital reverberation units (now refered to as Schr\u00f6der reverbs) worked by simply feeding the input signal through several dampened comb filters in parallel. With Mix around 20%, make a cloud of a dozen comb filters with frequencies around 20-50 Hz (the ear's integration time). Set Damp around 20% will get you a relatively natural reverberation, where the global decay time controls the reverb time (Snapshot 7). Adjust Predelay to taste; slightly and slowly agitating Transpose will help attenuating some the metallic resoance.</p>"},{"location":"modules/comb/#at-time-rate","title":"At time rate","text":"<p>A comb filter is a very short delay... but Comb also does longer delay! These will be heard as normal repetitions, so you can use Comb as (a set of) regular delays, with some twists. Add a single comb filter towards the lower frequencies, and put Transposition all the way down; you can reach delay times up to about half a second (2 Hz). Decay then controls the delay feedback, and the other controls well... you will have to experiment for yourself! Remember that everything (especially frequency/delay time) is modulatable.</p>"},{"location":"modules/control/","title":"Control","text":"<p>Patch tamer</p>"},{"location":"modules/control/#control","title":"Control","text":"<p>One big slider; its position is the modulation. Connect it to several destinations and adjust their dosages to get the desired macro-controller. Make it the entry point to a complex patch, or the hands-on control in your live performance. Smoothen, delay or loop your movements for predictable gestural transformations. Control is the simple yet powerful tool to reach patch-mastery.</p>"},{"location":"modules/control/#context","title":"Context","text":"<p>Atelier's modules expose parameters to the user that are mostly technical in nature (Pitch, Window, Spread...). Often, controlling a patch in a specific perceptual or artistic way involves moving several controls at once, in various proportions; this is where Control comes into play. At its core, it is a single slider, Value: when moved up or down, all its destination parameters move up or down by as much, taking modulation range into account. Therefore, patch-programming a complex macro-control amounts to connecting a Control to several parameters and adjusting each connection's modulation range, and mapping it to e.g. a MIDI controller:</p> <p>[Screenshot]</p> <p>Note</p> <p>Control is bipolar, meaning it moves equally above and below the destination parameter's set value. Therefore, to modulate across its full range of without clamping, the destination parameter must be centered and range set to 100%.</p> <p>Furthermore, Control provides additional tools to filter and transform the movements of the Value slider:</p> <ul> <li>Smoothing makes the movements of Value smoother, applying a low-pass filter to it,</li> <li>Delaying introduces a delay between the movement of Value and that of the destination,</li> <li>Looping allows to partially or completely repeat previous movements, and acts like a delay feedback, not on audio but on modulation.</li> </ul> <p>Keep in mind that like all parameters in Atelier, the Value slider can itself be modulated, and that this modulation itself is polyadic (see Modulations). Control can therefore be used as a filter for modulation signals, to smoothen, delay or loop them.</p>"},{"location":"modules/control/#controls","title":"Controls","text":"<p>Every parameter has as many independently-modulatable instances as there are outgoing instances of this modulator (ie. the sum of all wires' instance number, see Modulation).</p> <ul> <li>Value: Main value of the Control; modulated destinations are displaced by this amount.</li> <li>Smoothing time: Amount of smoothing applied to the Value parameter, or time it takes for it to reach its set value.</li> <li>Slant: Difference of slew times between rises and falls. At 0%, the rise and fall times are identical; at -100%, rises are immediate, at +100%, falls are immediate.</li> <li>Delay: Lag between a movement of the input (the Value parameter) and the corresponding movement of its output (what it is connected to).</li> <li>Loop: How much of past movements of Value is layered on top of the current movement. The delay parameter sets the time of the loop. At 100%, it creates an infinite loop of length Delay containing the last movements of the Value parameter. At 50%, the current Value is added the value it had Delay seconds ago, creating a slowly-settling feedback loop.</li> </ul> <p>Note</p> <p>The content of the Loop buffer is not saved with the patch; upon relaunch, it will be initialized to 0.</p>"},{"location":"modules/control/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/control/#live-controls","title":"Live controls","text":"<p>Connect Control to several destinations in a patch, adjusting the modulation range to taste so that movement of Value affects, say, the \"intensity\" of the sound. Assign Value to a MIDI potentiometer to play it in real time. Optionally, set Smooth to 10s; now you don't need your hand to make slow changes: brutally moving the potentiometer up will automate a gradual, 10s rise in intensity.</p>"},{"location":"modules/control/#delay-chains","title":"Delay chains","text":"<p>Instantiate a first Control; its Value will be your main point of entry. Instantiate 3 additional Control, each with Delay at 1s, and modulate each Value with the previous Control's output, creating a chain of 4 Control instances. Now connect each Control again to a separate destination (e.g. the Pitch from 4 Gen oscillators); each destination will follow the first Control's movements, with increasing lags.</p>"},{"location":"modules/control/#polyadic-delays","title":"Polyadic delays","text":"<p>Alternatively to the previous tip, a single Control might be enough to achieve a similar effect, thanks to the polyadicity of modulations. Modulate a few (say, 4) destination parameters with a Control; agitate its Delay parameter; this wire has 4 instances, so there are 4 independent agitation engines modulating Delay. Stop the agitation by disabling Running. Now each of the 4 destination parameter responds to the Control's Value with 4 different (randomly-chosen) delays.</p>"},{"location":"modules/control/#use-it-as-a-filter","title":"Use it as a filter","text":"<p>Again, thanks to polyadic modulations, A Control can be used as a filter for modulations. Instead of connecting a modulator, say Peak, directly to some destination(s), connect Peak to the Value of a Control, and connect this Control to the final destinations. Now, play with Smoothing time, Slant, Delay and Loop to modify the shape of the signal generated by Peak. Note that Peak's output is still polyadic, ie. there are as many independent Peak generators as there are destinations.</p>"},{"location":"modules/gain/","title":"Gain","text":"<p>A volume fader. Or is it?</p>"},{"location":"modules/gain/#gain","title":"Gain","text":"<p>Gain is the big fader of a mixer's channel strip: a simple volume control... but that's not all! The big Gain slider not only controls the amplitude of the incoming audio, but also affect its tonal and temporal characteristics to simulate a sense of distance from the source to the listener. Adjusted with care and modulated with taste, it is able to quickly give a sense of depth, movement and presence to the elements of a mix, difficult to achieve otherwise.</p>"},{"location":"modules/gain/#context","title":"Context","text":"<p>Before the advent of analog mixing boards, there was a single microphone at the center of the studio; musicians distributed in the room, and their distance to the microphone determined their loudness in the recording, but also the complex impression of \"remoteness\" we all intuitively know. Analog mixers reduced this natural set of cues to the bare minimum illusion: varying the gain of the signal. Yet, as sound has more distance to travel, it:</p> <ul> <li>arrives slightly later to the microphone,</li> <li>scatters and reverberate on the surfaces closeby, and</li> <li>sees its high-frequencies attenuated by the viscosity of air.</li> </ul> <p>All these phenomena contribute to the illusion of distance allowing the listener to perceive a sound stage. Gain attempts to simply but effectively mimick these effects, giving you control over the remoteness of a source, not just its gain. And combined with the modulation system, it is a surprising generator of sonic spaces, realistic or otherwise.</p>"},{"location":"modules/gain/#controls","title":"Controls","text":"<p>All parameters have as many independently-modulatable instances as there are input/output channels.</p> <ul> <li>Gain: Controls the volume, and the amount of \"distancing\" effect. At 0dB (maximum value), the audio is unaffected. As Gain is lowered, the audio is attenuated and more-and-more affected by Muffle and Distance.</li> <li>Trim: Adjusts the input gain, before applying the effect of Gain.</li> <li>Muffle: As Gain is lowered, sublty scrapes off high frequency content, attenuating harshness just like air does. It works by applying a gentle (6 dB/oct) low-pass filter, with a cutoff frequency determined by Gain and the percentage of muffling chosen: at 0%, no filtering is ever applied; at 100%, the cutoff gets smaller quickly when Gain lowers.</li> <li>Distance: As Gain is lowered, introduce a small delay, simulating the speed of sound in air, and a subtle room-like reverberation, simulating reflections against closeby surfaces.</li> </ul>"},{"location":"modules/gain/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/gain/#more-natural-fades","title":"More natural fades","text":"<p>Choose a well-known sound source (a simple saw wave works well). Listen to a few \"standard\" fade-ins/fade-outs (Muffle and Distance at 0%), turning Gain up or down slowly. Then increase Muffle and/or Distance (say, 50% each), and listen to a few fades again. Notice the enhanced, more natural sense of distance in the second case.</p>"},{"location":"modules/gain/#doppler-effect","title":"Doppler effect","text":"<p>When Distance is &gt;0%, moving Gain will modulate the speed-of-sound-simulating delay accordingly, as if the sound source was approaching/getting away from the listener. Just as in nature, you will perceive a slight change in pitch proportional to the speed at which Gain moves. This is the Doppler effect.</p>"},{"location":"modules/gain/#agitating-gain","title":"Agitating Gain","text":"<p>Instead of moving Gain by hand, try modulating it with an Agitation. Each channel having its own Gain parameter instance, they will be randomly modulated independently (see Modulations), giving rise to unpredictible and sometime surreal spatial movements; this is of course more dramatic the more channels are configured. Combine with Muffle or Distance to taste.</p>"},{"location":"modules/gen/","title":"Gen","text":"<p>Where signals spring</p>"},{"location":"modules/gen/#gen","title":"Gen","text":"<p>All music stems from a simple tone, a simple vibration through time. Shaped, attenuated or multiplied, modulated or processed, it gradually becomes noise, texture, melody, or symphony. Gen is where music starts: a simple yet versatile signal generator bank, with traditional waveforms and input analysis features. A world of generative possibilities.</p>"},{"location":"modules/gen/#features","title":"Features","text":"<ul> <li>Bank of signal generators (up to 16) spreadable in the multichannel space</li> <li>Four mixable waveforms per generator, each with a different morphing parameter</li> <li>Input envelope follower for gain following or ducking</li> </ul>"},{"location":"modules/gen/#context","title":"Context","text":"<p>In the pure tradition of modular synthesizers, and before them the test equipment used creatively by the pioneers of electronic music, Gen is a bank of complex signal generators. As soon as a generator is activated by clicking in the cursor area, it sounds continuously until stopped. No MIDI note or triggering events required, no duration.</p> <p>Gen can therefore be used to easily generate complex evolving drones, but it can be modulated so as to create triggerable discrete events or generative, random tones. All generators share the same complex waveform, chosen by mixing and warping the signals of four oscillators available in the waveform area:</p> <ul> <li>Sine with phase modulation</li> <li>Triangle with slope control</li> <li>Rectangle with pulse width control</li> <li>Filtered noise with filter control (from low-pass to band-pass)</li> </ul> <p>Just like all processors, Gen takes sound as input. This input can be passed through unaffected, mixed with the generators (Mix), but can also influence them: each generator embeds an independent envelope follower, able to modulate its own gain depending on the amplitude of the input, opening up adaptive reactions, and basic resynthesis.</p>"},{"location":"modules/gen/#controls","title":"Controls","text":""},{"location":"modules/gen/#waveform-area","title":"Waveform area","text":"<p>All parameters in the waveform area have as many independently-modulatable instances as there are generators (see Modulation).</p> <ul> <li>Sine gain: Gain of the sine oscillator.</li> <li>Triangle gain: Gain of the triangle oscillator.</li> <li>Rectangle gain: Gain of the rectangle oscillator.</li> <li>Noise gain: Gain of the filtered noise generator.</li> <li>Sine timbre: Amount of sine phase modulation.</li> <li>Triangle timbre: Morphs from saw to triangle wave.</li> <li>Rectangle timbre: Rectangle pulse width. Morphs from square wave to single-sample impulse.</li> <li>Noise timbre: Morphs from low-pass-filtered to resonant band-pass-filtered white noise.</li> </ul>"},{"location":"modules/gen/#envelope-follower-section","title":"Envelope follower section","text":"<ul> <li>Duck/Follow: At 0%, all generators are constantly on. At positive values (Follow), each generator gain follows more-and-more the amplitude envelope of the input signal. At negative values (Duck), each generator gain is reduced more-and-more when the envelope of the input signal increases.</li> <li>React: Envelope follower reactivity, or time it takes for the envelope follower to rise or fall when the input's gain envelope rises or fall. At 0s, it reacts instantly, resulting in ring modulation-type effects.</li> <li>Select: Frequency selectivity of the input envelope follower. How much each generator envelope follower listens only to frequencies close to that of this generator. This value is the Q factor of a band-pass filter applied to the input before envelope-following.</li> </ul>"},{"location":"modules/gen/#cursor-area","title":"Cursor area","text":"<p>Click to add a generator; double-click a generator to remove it. The following parameters are local to each generator:</p> <ul> <li>Pitch: Pitch of the generator.</li> <li>Spread: Channel-locality of the generator (see Spread below). At 0%, the generator outputs only to the channels it is assigned to (see the global Spread section); at 100%, the generator outputs on all channels.</li> <li>Gain: Individual gain of the generator.</li> </ul> <p>Additional controls:</p> <ul> <li> <p>Ratio: Ratio by which all generator's frequencies are multiplied. Has as many independently-modulatable instances as there are generators (see Modulation).</p> </li> <li> <p>Quantize button: click to quantize all generator pitches to the closest semitone.</p> </li> </ul>"},{"location":"modules/gen/#global-controls","title":"Global controls","text":"<ul> <li>Mix: Crossfades between the input signal (0%) and the oscillators signal (100%).</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are generators (see Modulation):</p> <ul> <li>Spread: Global channel-locality of all generators. This value is added to the local Spread of each generator.</li> <li>Gain: Global gain of all generators.</li> </ul>"},{"location":"modules/gen/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/gen/#modulating-gain","title":"Modulating gain","text":"<p>Start with a few sine generators, laid out to make a nice drone chord or cluster. Now set the global Gain to -10dB (centered), and agitate it. Each generator's gain is agitated independently, producing pleasantly animated swashes of sines. From there, focus on the agitation: Cyclic at 100% will repeat a pattern; Slant at -100% and Ease around 50% will produce decaying transients. Increase Jitter to 5% so the rhythmic pattern evolves slowly.</p>"},{"location":"modules/gen/#modulating-waveform","title":"Modulating waveform","text":"<p>We wrote above that all generators share the same waveform, but this is not strictly true! All parameters in the waveform area have independently-modulatable instances for each generator. Adding a few generators and agitating e.g. Sine timbre will modulate the timbre of each generator independently. Be gentle with the modulation range and create living, evolving timbres.</p>"},{"location":"modules/gen/#make-a-vocoder","title":"Make a vocoder","text":"<p>Feed a voice into Gen. Add 16 sine generators spread out evenly through the whole frequency range. Put Mix and Spread at 100% to get a loud drone. Put Duck/Follow at 100%; the drone now follows the gain of the input. Now increase Select so each generator follows the gain of the input selectively around its own frequency. Notice how words of the input voice become more-and-more recognizable. It is composed of only 16 sine waves.</p> <p>You just made a vocoder: it analyses the input signal and resynthesizes it with a small number of sine waves. Now you can play with various input material, various waveforms in Gen, various generator frequencies.</p>"},{"location":"modules/gen/#slow-impulses","title":"Slow impulses","text":"<p>The Ratio control goes all the way to 0x, allowing sub-audio generator frequencies. While a sine wave won't be hearable at these rates, waveforms with discontinuities will make repeated clicks. Especially nice are 1-sample impulses from the rectangle oscillator, that can then be filtered through Band or Comb. Several of these generators at will produce interesting chaotic rhythms.</p>"},{"location":"modules/gen/#randomize-all","title":"Randomize all","text":"<p>Patch randomization is a fun way to explore Gen's tonal palette. Add a few (4) generators anywhere, and agitate e.g. Gain and Ratio (optionally, experiment with modulating these modulators). Lock the global controls (Mix, Gain and Spread) as well as Duck/Follow. Now press the patch-wide Randomize button a few times. You will be surprised.</p>"},{"location":"modules/peak/","title":"Peak","text":"<p>Everything transient</p>"},{"location":"modules/peak/#peak","title":"Peak","text":"<p>Peak is a simple envelope generator: it rises, then falls back down. Assign it to the gain of a sound source, you now have an actionable events trigger. But with its adjustable shape, looping and probability features, it goes a lot further than the traditional Attack-Decay envelope found in synthesizers, and combined with Atelier's rich modulation system it is able to generate a wide range of automatable transient waveforms... expected and unexpected.</p>"},{"location":"modules/peak/#context","title":"Context","text":"<p>The simple two-segments envelope (Attack-Decay or Attack-Release) is the building block of envelope generators, from Serge's DUSG to GRM's own Coupigny synthesizer with its \"G\u00e9n\u00e9rateur d'envelope\".</p> <p>By default, it sits at zero (i.e. it does not change the value of its destination). When triggered, it waits a bit (Delay seconds), then rises to its maximum value (set by Amplitude), optionally holds there until released (Hold) then falls again to zero. Triggering it means clicking on (or holding) the Trigger button or a mapped MIDI control, but Trigger, like any parameter, can itself be modulated: just drag a wire from your modulator of choice to the Trigger button (in this case a positive modulation means triggered, a negative one means released). But triggering is always conditioned on a certain probability, set by Chance.</p> <p>Once reaching zero again it can optionally retrigger. This depends on Repeat, which sets a fixed set of (unconditional) repeats and Infinite repeat, which makes Peak acts like an LFO.</p> <p>Note</p> <p>Peak is unipolar, meaning it only moves up from the destination parameter's set value. Therefore, to modulate across its full range of without clamping, the destination parameter must be set to its lowest value, and range set to 100%.</p>"},{"location":"modules/peak/#controls","title":"Controls","text":"<p>Every parameter has as many independently-modulatable instances as there are outgoing instances of this modulator (ie. the sum of all wires' instance number, see Modulation).</p> <ul> <li>Trigger: Triggers the envelope, i.e. begins the rise stage. If held and Hold on, holds at maximum value once reached.</li> <li>Time: Total time of the envelope, including repeats, at full amplitude.</li> <li>Slant: Ratio of the time spent going up vs. down.</li> <li>Ease: Shape of the rise and fall curves (logarithmic, sine, linear, s-shaped, exponential).</li> <li>Delay: Delay before starting to rise, after being (re-)triggered.</li> <li>Repeat: Number of retriggers after a Trigger or a repetition. Keeps the total Time constant.</li> <li>Chance: Probability that Trigger actually triggers.</li> <li>Amplitude: Envelope starts falling or holding when this value is reached.</li> <li>Hold: When off, envelope falls right after reaching Amplitude. When on, holds at maximum value until Trigger is released.</li> <li>Infinite repeat: Loop the envelope indefinitely. When enabled, Trigger re-triggers or holds the envelope.</li> </ul>"},{"location":"modules/peak/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/peak/#random-triggers","title":"Random triggers","text":"<p>Make four or five sine wave generators with Gen at various frequencies (why not make a chord). Set its global Gain to -\u221e, and modulate it with a Peak. Set Slant to -100%, Chance to about 40%, and enable Infinite repeat. Since each oscillator is now driven by an independent instance of the Peak engine, each oscillator will be triggered with an independent probability at fixed intervals. Increase Repeat to make little note clusters.</p>"},{"location":"modules/peak/#a-basic-kick-drum","title":"A basic kick drum","text":"<p>Start with a single Peak, with Time=0; its Trigger will act as our main trigger. Make two additional Peak with Slant=-100%; one will be our amplitude envelope, the other our pitch envelope. Make a 50Hz sine-wave with Gen, and modulate Gain with the amplitude envelope, and Ratio with the pitch envelope. Triggering the main Peak produces a sine Adjust times, modulation amounts and Ease to taste. For more impact, you can add a third pitch-modulating Peak with a smaller Time to make a click.</p>"},{"location":"modules/peak/#make-an-adsr","title":"Make an ADSR","text":"<p>The standard ADSR envelope (Attack-Decay-Sustain-Release) is easily constructible: take two instances of Peak that will be triggered at the same time: one with Hold off (the AD), one with Hold on (the AR), and sum them together by dragging a wire from each to the same destination, adjusting their respective modulation ranges. Both rise times correspond to Attack, the fall time of the AD corresponds to Decay, the fall time of the AR corresponds to Release and the modulation range ratio corresponds to Sustain.</p>"},{"location":"modules/pitch/","title":"Pitch","text":"<p>Not a pitch shifter</p>"},{"location":"modules/pitch/#pitch","title":"Pitch","text":"<p>A pitch shifter changes the pitch of a sound without changing its duration. On the surface, this is what Pitch is: a bank of pitch shifters combined with delays, placed on a convenient 2D surface. But rather than delivering just this, Pitch deconstructs the concept and exposes it, piece by piece. Used for classic pitch tricks or to explore a wealth of novel ideas, Pitch is more than just what its name suggests.</p>"},{"location":"modules/pitch/#features","title":"Features","text":"<ul> <li>Up to 8 pitch shifters/granular delays, placed on an intuitive 2D surface</li> <li>Wide transposition &amp; delay range: from +48 semitones to -\u221e, up to 10 seconds delay</li> <li>Freeze function to scrub inside buffer</li> <li>Widely adjustable window size &amp; correlation detection</li> </ul>"},{"location":"modules/pitch/#context","title":"Context","text":"<p>Feed sound into Pitch, click to add a pitch shifter: the sound is delayed and transposed.</p> <p>But what actually happens is not magic: the input is recorded into a buffer, and two overlapping playheads continuously read small grains of sound around the cursor (the delay time), at a speed proportional to the transposition required. Basic pitch shifting is just this: playing small overlapping grains of the input sound at speeds different than the recording speed!</p> <p>Combined with correlation detection to adjust grain positions, this overlap/add technique is the archetype of pitch shifting algorithms (WSOLA), and with short grain size and strong correlation detection, it works especially well on monophonic sounds; otherwise artifacts start to be heard.</p> <p>Pitch can act as a convincing bank of pitch shifters, but really shines when breaking free from its traditional use, leveraging its very nature: with a wide range of grain sizes (from 4 ms to 2 seconds), adjustable correlation detection and freezing, you can explore playing with granular scrubbing, transient doubling or amplitude modulation artifacts in new, creative ways.</p>"},{"location":"modules/pitch/#controls","title":"Controls","text":""},{"location":"modules/pitch/#cursor-area","title":"Cursor area","text":"<p>Click to add a pitch shifter; double-click a pitch shifter to remove it. Each pitch shifter runs in parallel with its own buffer; they are then mixed to the output.</p> <p>The following parameters are local to each pitch shifter:</p> <ul> <li>Delay (X axis): Pitch shifter delay time.</li> <li>Pitch (Y axis): Pitch shifting amount. Sets the grains playback rate relative to normal rate.</li> <li>Gain (Z axis): Pitch shifter gain.</li> <li>Freeze button: Stops feeding audio into this pitch shifter buffer, and read current content in-place.</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are pitch shifters (see Modulation):</p> <ul> <li>Freeze button: Inverts the Freeze state of all pitch shifters (see local Freeze parameter).</li> <li>Delay ratio: Scales all delays by the given ratio.</li> <li>Rate: Scales all pitches by the given ratio. Negative ratios mean reverse grain playback.</li> </ul> <p>Finally two buttons at the top modify the state of Pitch:</p> <ul> <li>Quantize: click to quantize all pitches to the closest semitone.</li> <li>Clear all buffers: click to silence all delay buffers</li> </ul>"},{"location":"modules/pitch/#global-controls","title":"Global controls","text":"<ul> <li>Mix: Crossfades between the dry (0%) and the wet signal (100%).</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are pitch shifters (see Modulation):</p> <ul> <li>Spread: Channel-locality of each pitch shifter. At 0%, each pitch shifter processes only the channels it is assigned to (see the global Spread section); at 100%, all pitch shifters process all channels in parallel (multi-mono).</li> <li>Gain: Global gain of all pitch shifters.</li> <li>Feedback: How much of each pitch shifter's output is reinjected into its input. Feedback is local to each pitch shifter. As feedback gets higher, repetitions are displayed as dots where they will appear in the cursor area.</li> <li>Window: Duration of the pitch-shifted grains.</li> <li>Detect: Precision of the correlation detection. At 100%, a correction is applied to each grain starting position to correlate better with the currently playing grain to avoid phase cancellations. At 0%, this correction is disabled, resulting in an amplitude modulation-type effect.</li> <li>Rotate: Rotates the channels in the feedback path. At 0%, each channel's feedback paths is completely independent; at 100%, each channel feeds back into its successor and the last one feeds back into the first, resulting in a generalized ping-pong delay-like effect.</li> </ul>"},{"location":"modules/pitch/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/pitch/#harmonize","title":"Harmonize","text":"<p>A staple of studio effects: with a voice or solo instrument as input, just add two 0-delay pitch shifters at pitches close to zero. The voice is doubled and thickened. reduce Spread to increase the width effect to taste. Add more pitch shifters at harmonic intervals to make chords.</p>"},{"location":"modules/pitch/#granulator","title":"Granulator","text":"<p>Now move the Delay of individual pitch shifter manually (hold <code>\u2325</code> to lock the Y axis). Since delay changes only happen when a new grain starts, the material gets scrubbed granularly without repitch. You can modulate Delay to automate this movement: small &amp; fast random modulation will scatter grains like a typical granular effect; large &amp; slow modulation will slow down or speed up the material. Play with Window and listen its effect on grain size while Delay is modulated.</p>"},{"location":"modules/pitch/#a-sequencer-for-audio","title":"A sequencer for audio","text":"<p>Disable modulations and use Delay to spread out the chord in time. If fed with a single isolated tonal event (a note), it will go through each pitch shifter successively, repeating it in a sequence. To quantize events in time, use time graduations, and then Delay ratio to match your desired tempo. Play with Feedback and adjust pitches and timings so that repetitions interact in interesting temporal and harmonic patterns.</p>"},{"location":"modules/pitch/#walk-the-frozen-buffer","title":"Walk the frozen buffer","text":"<p>At any time, enabling Freeze (locally on a pitch shifter or globally) will stop the buffer and play continuously from the pitch shifter's positions, allowing to scrub through the material freely. Note that all Freeze buttons are modulatable.</p> <p>Note</p> <p>The content of Pitch's buffer is not saved when a patch is saved. Next time you open it, you need to reload audio material into it.</p>"},{"location":"modules/pitch/#switch-off-your-targeting-computer","title":"Switch off your targeting computer","text":"<p>Correlation detection (Detect) slightly adjusts the start position of each grain so that it aligns as much as possible with the previous one, minimizing phase cancellation \"artifacts\" at the junction between two grains. With large grains, this is heard as \"beatings\", i.e. changes in amplitude; with small grains, this is heard as a pitched amplitude modulation. Use the artifact creatively: set a small Window, disable Detect and play with Pitch to chase interesting formant-shifting effects.</p>"},{"location":"modules/play/","title":"Play","text":"<p>Audio file playground</p>"},{"location":"modules/play/#play","title":"Play","text":"<p>Simple file playback, turned into an instrument. Play is a virtual tape recorder with creative feature: multiple playheads, versatile playback region, envelope control, and built-in recording functionality allowing input sampling or even resampling your own patches. Endless sound material exploration without cluttering your desk with snippets of magnetic tape.</p>"},{"location":"modules/play/#features","title":"Features","text":"<ul> <li>Multiple playheads with adjustable pitch and position</li> <li>Built-in recording into a temporary buffer, saveable to file</li> <li>Looped and single shot playback</li> <li>Global and individual transport controls for each playhead</li> <li>Playback in forward and reverse direction</li> </ul>"},{"location":"modules/play/#context","title":"Context","text":"<p>Spliced tape, varispeed and reversed reels: in the hands of musique concr\u00e8te composers, the reel-to-reel recorder became an instrument, turning sound itself into material for playful experimentation. Play taps into this history and brings it to modern standards, while treasuring the joy of experimenting.</p> <p></p> <p>Once a file is loaded, place one or several readheads. Each readhead is represented by a cursor, that has independent pitch, playback position and gain. Its position is confined to a playback region (in blue in the region overview).</p> <p>An envelope is applied while reading the region (Fade, Slant). In single-shot playback, playheads start fading in at the beginning of the region, then fades out again at its end. In looped mode, it determines crossfade: as soon as fade out starts, the region starts playing again from the start. With Fade at 100% the playback continuously overlaps.</p> <p>Play can load mono, stereo and multichannel audio files. If the number of channels in the audio file don't match the number of channels of the module fanning and folding is employed to distribute the channels to your outputs.</p>"},{"location":"modules/play/#controls","title":"Controls","text":""},{"location":"modules/play/#toolbar","title":"Toolbar","text":"<ul> <li>Play/pause: Global transport state. Toggles playback of all playheads, stopping or resuming playback from their last position. This parameter has as many independently-modulatable instances as there are playheads (see Modulation).</li> <li>Stop: Immediately stops playback of all playheads, and reset to their start position.</li> <li>Loop/single shot: When toggled on, playback loops until paused. When toggled off, the region plays once until Play/Pause is toggled another time.</li> <li>File browser: Shows the currently loaded file. Click to bring up a list of audio files in the same directory. When hovered, shows file information in the info area.</li> <li>Record: Records the input of the module into a temporary buffer (max. 1 minute).</li> <li>Save: Save temporary buffer to file.</li> <li>Open file: Opens an audio file.</li> </ul> <p>Tip</p> <p>Play/pause, Loop and especially Record are all modulatable!</p>"},{"location":"modules/play/#region-overview","title":"Region overview","text":"<p>The region overview shows a view of the entire file, the playback region and the envelope. Click-and-drag the waveform to zoom and pan. The blue translucent bar at the top shows the playback region. Vertically drag it to shrink/enlarge the region, horizontally drag to move. Additionally, start and end vertical bars can be adjusted by dragging. Holding down alt while dragging anywhere on the waveform allows to define a new playback region.</p>"},{"location":"modules/play/#cursor-area","title":"Cursor area","text":"<p>Click to add a playhead; double-click a playhead to remove it.</p> <ul> <li>Quantize button: Click to quantize all playhead pitches to the closest semitone.</li> <li>Rate: Playback speed, relative to nominal file speed. Negative means reverse. This parameter has as many independently-modulatable instances as there are playheads (see Modulation).</li> </ul> <p>Each playhead has four controls:</p> <ul> <li>Play/Pause button: Playhead playback state. If global playback is enabled, this control is inverted.</li> <li>Start (X axis): Playhead position after it ended playing, or the Stop button was pressed. If the start position lays outside of the playback region (less than 0% or more than 100%) playback will start with a delay.</li> <li>Pitch (Y axis): Playhead playback speed, in semitones relative to nominal file speed.</li> <li>Gain (Z axis): Playhead output gain.</li> </ul>"},{"location":"modules/play/#global-controls","title":"Global controls","text":"<ul> <li>Mix: Crossfades between the input signal (0%) and the playheads signal (100%).</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are playheads (see Modulation).</p> <ul> <li>Position: Center position of the playback region.</li> <li>Duration: Duration of the playback region, as a percentage of the total file length. The actual duration in seconds is indicated next to this slider.</li> <li>Spread: Channel-locality of each playhead. At 0%, each playhead reads only the channels it is assigned to (see the global Spread section); at 100%, each playhead reads all channels of the file.</li> <li>Gain: Output gain of all playheads. Added to the gain of playhead.</li> <li>Fade: Combined length of the fade-in and fade-out envelope. In loop mode, it determines the cross fade time.</li> <li>Slant: Ratio of time spent fading in vs. fading out. At 0% the attack is instant and the entire time is used for the fade out; at 50% the envelope is symmetric; at 100% the envelope is slanted towards the right.</li> <li>Ease: Easing curve of the applied fades, from linear (0%), to abrupt (100%).</li> <li>Declick: Minimum time of any fades. A value of 0 allows clicks; anything above quickly fades any transition: start, stop, (cross-)fade.</li> </ul>"},{"location":"modules/play/#tips-and-tricks","title":"Tips and tricks","text":"<p>Note</p> <p>Dragging an audio file from Ateiler's own patch recorder or the system\u2019s file explorer anywhere into the processor chain creates an instance of Play with the file in place.</p>"},{"location":"modules/play/#phasing","title":"Phasing","text":"<p>To achieve a phasing effect \u2014 as popularized by Steve Reich \u2014 place two playheads at the same exact spot. Changing the Start of one playhead introduces a fixed time gap between both heads; slightly changing Pitch instead gradually desynchronizes both playheads. Hold <code>\u21e7</code> while dragging for fine control. This effect is easiest explored with short rhythmical loops.</p>"},{"location":"modules/play/#granular-playback","title":"Granular playback","text":"<p>Try repeating tiny segments \u2014 or grains \u2014 of audio (typically 1 to 100 milliseconds), and modulating the region. Set the Duration to a very small value. Add a generous amount of Fade to smooth out the grains. Add several playheads with different pitches to create a chord. Reset the position to 50%. Now add a modulation to Position, Peak to create a constant ascending slope, or Agitation for unexpected scrubbing. Adjust its time to vary the granular scrubbing speed.</p>"},{"location":"modules/play/#percussions-with-drone-material-using-fades","title":"Percussions with drone material using fades","text":"<p>Using envelope shapes it is easy to reappropriate drone-y material for percussive sounds. Create one or more playheads, adjust the duration and bring Slant to 0%. Adjust Ease to make a fast decay. If you want sharp, clicky attacks set Declick to 0ms. Optionally modulate Position to get more variety. Tip: this might pair nicely with Comb further down the chain.</p>"},{"location":"modules/play/#multichannel-cannon","title":"Multichannel cannon","text":"<p>When a playhead's Start (X axis) parameter is less than 0% it will start out muted until it reaches the playback region. This effect can be exploited to create cannons. Place several playheads in a row, spacing Start at regular intervals before 0%. Make sure all Pitch are equal. Now, when you press Play, one playhead after the other will reach the the playback region with the predefined delay. Once they reached the end of the region they will loop and start from the beginning, creating a cannon.</p> <p>If you want to play the cannon in reverse, move all the playheads so their Start is after the 100% marker, and set Rate to -1x.</p>"},{"location":"modules/time/","title":"Time","text":"<p>Temporal machine</p>"},{"location":"modules/time/#time","title":"Time","text":"<p>Time is a delay unlike any other. An exploration of how far the concept of a delay can be pushed into uncharted territories. In its simplest form, it takes audio as input, stores it in a buffer and replays it a while later. But with up to 32 freely-tunable taps, variable transport speed, continuous granular playback and per-tap band-pass filters, it can reach sound transformations yet unheard of. Time is the ace of spades of time-domain operations.</p>"},{"location":"modules/time/#features","title":"Features","text":"<ul> <li>freely-tunable delay with multiple tap. Up to 32 taps, from milliseconds to minutes.</li> <li>per-tap resonant band-pass filter</li> <li>variable-rate read/write speed</li> <li>continuous control of repitching vs. granular (crossfading) playback</li> </ul>"},{"location":"modules/time/#context","title":"Context","text":"<p>From the advent of magnetic tape to digital storage, using the medium as short-term storage for sound is an infinite source of sound manipulations.</p> <p></p> <p>In the late 1950s, GRM started producing a series of revolutionary tape-playing machines used as sound processing instruments, the Phonog\u00e8nes and Morphophones. Using complex pulley mechanisms and read-head drums, they could read small chunks of tapes at speeds independent of the tape transport, inventing the granular playback techniques that still power pitch shifting and time stretching algorithms nowadays. Using multiple read heads, arbitrarily placed on the tape and filtered indepedently, they could break free from the repetition of the simple feedback loop, radically transforming input sound material.</p> <p>Time takes up where these machines left off, maintaining the tape analogy that makes things logical and easy to understand. At its heart, Time provides a large audio buffer, which the module's input is continuously written to. At any point in this buffer, one can place a read head (a tap), that reads the written material with a delay. The speed at which this buffer goes by is variable (Speed); like tape, the slower the speed the more delay, and the more the signal is degraded: there are less samples to record a given audio chunk.</p> <p>Each tap is actually made of two read heads quickly relaying each other in reading the audio at their position (granular playback). Therefore, if the delay time is changed, it smoothly crossfades to the new position without clicks or repitches. In fact, and contrarily to usual delays, this crossfade time is freely settable (Repitch/Fade:), allowing for repitches, crossfades and a wealth of interesting in-betweens.</p> <p>Just like on the Morphophone, each tap then goes to a band-pass filter (Bandpass) which resonant frequency can be set (Cutoff), and is then summed to the output. The feedback loop (Feedback) reinjects this sum back into the input, resulting in potentially complex impulse responses and reverberation-resonator-delay hybrids.</p>"},{"location":"modules/time/#controls","title":"Controls","text":""},{"location":"modules/time/#cursor-area","title":"Cursor area","text":"<p>Click to add a tap; double-click a tap to remove it. Each tap reads from the same audio buffer at different delay times; it is then band-pass-filtered indepently and summed to the output and to the feedback path.</p> <ul> <li>Clear audio buffer: instantly clears all audio material in the buffer.</li> <li>Y axis parameter: The combo box determines which parameter is displayed on the Y axis (and consequently which is displayed on the Z axis, ie. cursors' halo size): either Gain or Cutoff.</li> </ul> <p>The following parameters are local to each tap:</p> <ul> <li>Delay (X axis): Delay time of the tap.</li> <li>Gain (Y or Z axis): Gain of the tap.</li> <li>Cutoff (Z or Y axis): Band-pass filter cutoff frequency of the tap.</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are taps (see Modulation):</p> <ul> <li>Delay scale: Scales all delay times by the given ratio.</li> <li>Transposition: Transposes the cutoff frequencies of all taps.</li> </ul>"},{"location":"modules/time/#global-controls","title":"Global controls","text":"<ul> <li>Mix: Crossfades between the dry signal (0%) and the wet signal (100%).</li> <li>Speed: Transport speed, or how fast the digital \"tape\" is moving. Affects the speed at which the input audio is written to the buffer, as well as the read speed. At speeds &lt; 1x, there are less samples to record the incoming audio, so the fidelity is (interestingly) degraded.</li> <li>Rotate: Rotates the channels in the feedback path (see Feedback). At 0%, each channel feeds back into itself; at 100%, each channel feeds back into the next one, and the last one feeds back into the first, resulting in a generalized ping-pong delay-like effect.</li> </ul> <p>The following parameters have as many independently-modulatable instances as there are taps (see Modulation):</p> <ul> <li>Spread: Channel-locality of each tap. At 0%, each tap outputs only on the channels it is assigned to (see the global Spread section); at 100%, each tap plays all channels in parallel (multi-mono).</li> <li>Gain: Global gain of all taps</li> <li>Feedback: Amount of the sum of all taps that is fed back into the input. Careful: with several taps, may bloom and provoke loud sounds (even under 100%). To make blooming less aggressive, the feedback path includes a soft-clipping stage.</li> <li>Bandpass: How much band-pass filtering is applied to each tap. The bigger this value, the more resonance (or Q-factor) the band-pass filter has. 0 means no filtering at all.</li> <li>Repitch/Fade: Duration of the tap's playback grains. When &gt;0, a change in delay time will result in a crossfade, hence no repitch; at 0, grains are so small that playback is continuous, which repitches the input when delay time is changed. Grains are always played at speed 1, so lowering Speed while this is &gt;0 will result in constant repitching.</li> </ul>"},{"location":"modules/time/#tips-and-tricks","title":"Tips and tricks","text":""},{"location":"modules/time/#rhythmic-taps","title":"Rhythmic taps","text":"<p>Feed Time some simple rhythmic loop. Introduce a few taps, and arrange them in time so that they repeat incoming audio in a rhythm of your choosing. Vary their gain and/or cutoff to taste. Tuning is a precise but rewarding process, as you discover new syncopations and grooves.</p>"},{"location":"modules/time/#complex-looping","title":"Complex looping","text":"<p>With a single tap set to a long delay (several seconds), Time can be used as a simple looper: just crank Feedback to 100% and the material in the buffer will accumulate and repeat indefinitely (this is Snapshot 5). Start here: feed some live-played input (voice, guitar, synth) and build layers upon layers, interacting with past material as if it was another player.</p> <p>From here, try out a few tricks: modulate the delay time slightly for imperfect repetitions, lower Speed and/or increase Bandpass for generational degradation, add a second tap closeby for complex stereo interplays... the world of delays is your oyster.</p>"},{"location":"modules/time/#flangers-choruses-and-all-that","title":"Flangers, choruses and all that","text":"<p>Flanger, chorus, ensemble, vibrato... all these classic effects are just variants of the same concept that can easily be recreated with Time: short delays (1 to 50 ms) modulated by LFOs. Mixing the dry and delayed signals carves out pleasing peaks and troughs into the frequency content of your audio.</p> <p>An Agitation with 100% Cyclic will do the LFO. Add one or several taps around 10 ms, and modulate their delay times (use Delay scale). Increase Rotate for stereo width. Increase Feedback to taste. This is your bread-and-butter modulation effect; now explore this space for effects unheard of: different LFO shapes, audio-rate modulation, degrading with Speed and Bandpass, fade instead of repitch...</p>"},{"location":"modules/time/#precedence-effect","title":"Precedence effect","text":"<p>One important cue to the localization of sound is its relative time of arrival: if one ear receives a sound before the other, the source will appear closer to it. A delay of a couple milliseconds is enough to trick our brain. It is sometimes called the Haas effect.</p> <p>Replicate this in Time: in stereo and listening on headphones, add two taps: one at 0 ms, one around 2 ms. Set Spread to 0% and Mix to 100%. Your input will sound like it leans to the left, even though the gain of each channel is the same. Vary the right-ear delay time and observe the effect.</p> <p>Using this creatively is a well of interesting ideas: the same principle with 4 or 8 channels (introducing the same number of taps) creates impossible spatial effects; modulating delay times instantly densifies simple material.</p>"},{"location":"modules/time/#reverb-tails","title":"Reverb tails","text":"<p>As soon as more than one tap is introduced, Feedback will not sound like your standard repetitions. This is because what is fed back is the sum of all individual taps. For instance, with two taps at 1 and 0.1 seconds respectively and feedback high enough, you will get repetitions at seconds 0.1, 1, 1.1, 2, 2.1, 2.2, 3, 3.1, 3.2, 3.3 etc.: as the repetitions tail off, they become \"denser\" (closer to each other). This can be used at your advantage: with &gt;4 taps and carefully choosing their times, we can come up with delay tails that quickly densify like reverbs, resulting in a variety of hybrid reverb/delay effects. This is especially true when delay times are slowly and slightly modulated, to cut off any resonance buildups.</p>"},{"location":"modules/viz/","title":"Viz","text":"<p>Sound insight</p>"},{"location":"modules/viz/#viz","title":"Viz","text":"<p>Viz is a complete toolset to probe and visualize multichannel signals anywhere in the audio chain. It features VU-meters, a spectrum analyzer/spectrogram, a correlation meter and an oscilloscope, all adapting to your channel configuration. From a bird's eye view down to sample accurate measurements, Viz is a visual insight into sound.</p>"},{"location":"modules/viz/#features","title":"Features","text":"<ul> <li>Fully multichannel signal analyzer, with zoomable and pausable views</li> <li>Full-featured oscilloscope with large, freely-explorable buffer</li> <li>Precise spectrum analyzer and spectrogram</li> <li>Unique multichannel correlation meter</li> </ul>"},{"location":"modules/viz/#introduction","title":"Introduction","text":"<p>Viz was originally conceived as an internal tool for development and debugging, but quickly turned out to be a valuable asset for audio signal processing education, patch troubleshooting... or simply for the good looks. So here it is!</p> <p>It consists of four analysis tools: a VU-meter, a spectrum analyzer, a correlation meter, and an oscilloscope. The window is split accordingly into four zones that can be freely resized.</p>"},{"location":"modules/viz/#controls-and-vu-meters","title":"Controls and VU-meters","text":"<ul> <li>Pause: Pauses input when toggled on, freezing all displays. Views can be explored (zoomed etc.) during pause.</li> <li>Channel mute: Clicking toggles channel muting;  <code>\u2318</code>-click solos a channel. Dragging toggles several channels at once.</li> </ul> <p>The VU-Meters show, in each channel's color:</p> <ul> <li>the RMS loudness as a gradient in the channel's color,</li> <li>its peak value as a solid bar,</li> <li>a clipping indicator (peak values above 0 dBFS) as a red square</li> </ul> <p>Underlaid in white is the sum of all channels. Hover over a VU-Meter to see a numerical readout in the info area. Click to reset clipping indicator.</p>"},{"location":"modules/viz/#spectrum-analyzer","title":"Spectrum analyzer","text":"<p>The spectrum analyzer displays the frequency contents of the incoming audio in two different views: the spectrum display and the spectrogram. Each channel is toggleable and overlaid with its own color. Both views are zoomable. Raw FFT signals can be hard to parse, therefore two adjustable smoothings are applied before display: frequency axis smoothing to get a broader view of the spectrum (Smooth), and time axis decay smoothing to better identify peaks  (Release).</p> <p>Hover over the display to get a readout of the current value. Drag vertically to zoom in, horizontally to pan into the view. Double-click to reset.</p> <ul> <li>Channel selectors: Clicking toggles channel visibility. White toggles display of the sum of all channels.</li> <li>Spectrogram button: Toggles between spectrum and spectrogram display.</li> <li>FFT size: FFT size of the spectrum analyzer (tradeoff between time and frequency precision).</li> <li>Smooth: Frequency smoothing amount. The more smoothing applied, the less frequency-domain details are visible.</li> <li>Release: Each frequency's release time.</li> <li>Spectrum amplitude range: Adjusts the displayed dynamic range.</li> </ul>"},{"location":"modules/viz/#correlation-meter","title":"Correlation meter","text":"<p>The correlation meter is a quick way to visualize the relationship between channels, see where energy is located and identify potential phase opposition problems. It is a multichannel generalization of the classic stereo goniometer. Each channel is identified by a colored square. It continuously computes the correlation between each pair of channels, and displays a white dot for each channel. The size of the dot is the signal's amplitude. Its position depends on the correlation of its channel with all other channels: by default it sits on its channel; the more this channel is in phase with the other, the more it is attracted to it; the more out of phase it is, the more it is repelled by it. Therefore:</p> <ul> <li>Completely uncorrelated signals will be displayed as dots sitting mostly around their respective channels.</li> <li>Identical signals on all channels will be displayed as dots all sitting in the middle.</li> <li> <p>If a pair of channels has signals out-of-phase, their dots will sit outside the line segment they form.</p> </li> <li> <p>Correlation meter zoom: Display zoom.</p> </li> </ul>"},{"location":"modules/viz/#oscilloscope","title":"Oscilloscope","text":"<p>The oscilloscope provides a sample-accurate view of the input signal in the time domain. Each channel is displayed in its color, and can be toggled on or off. An additional white channel represents the sum of all channels. It has a large, 10-seconds audio buffer, easily explorable by zooming in and out, from seconds-long to individual samples display. Just like its hardware counterpart in electronics labs, the scope only draws the current waveform on screen when triggered by a certain event: repeatedly (Frequency), when the signal crosses the 0-boundary (Rising edge) or by estimating its most probably period (Autocorrelation). The rightmost edge of the display is when the event happened.</p> <p>Hover over the display to get a readout of the current values. Drag vertically to zoom; drag horizontally to pan into the view. Double-click to reset zoom.</p> <ul> <li>Vertical range: Zooms vertically into signal amplitude</li> <li>Channel selector: Toggles channel visibility. The white button toggles the display of the sum of all channels.</li> <li>Trigger source: Selects which event triggers a refresh of the scope's display:<ul> <li>Frequency: the scope is refreshed at regular intervals, according to Trigger frequency.</li> <li>Rising Edge: the scope is refreshed whenever the Trigger channel goes from below to above the Rising edge threshold, which is by default zero.</li> <li>Autocorrelation: the signal's most probable period is computed, and the scope is triggered regularly at this period. This is the easiest way to get a steady reading of periodic waveforms.</li> </ul> </li> </ul> <p>Note</p> <p>When Autocorrelation is selected, additional info is overlaid on top of the waveform view:</p> <ul> <li>the autocorrelation waveform is displayed as a grey line</li> <li>a vertical dotted bar indicates the most probable period</li> <li>the hover display shows the signal's determined frequency and period</li> </ul> <ul> <li>Trigger channel: When Trigger source is Rising Edge or Autocorrelation, sets the channel used for triggering.</li> <li>Trigger frequency: Controls how often the display is refreshed when Trigger source is set to Frequency</li> <li>Rising edge threshold: When Trigger source is Rising Edge, a draggable horizontal dotted line appears on the display. It sets the threshold the signal must pass to trigger a refresh.</li> </ul>"}]}